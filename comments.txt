//------------ СНАЧАЛА ТО, ЧТО НЕ ПОЛУЧИЛОСЬ РЕАЛИЗОВАТЬ:

- в компонентах карточек (CardPerson, CardPlanet, CardSpaceship) есть useEffect, который служит двум простым целям. Во-первых, при componentDidMount(), который useEffect и имитирует, у карточки убирается CSS-класс, который её скрывает, получается плавная анимация появления. Во-вторых, глобальная переменная numOfCards инкрементируется и document.title обновляется. Проблема в том, что useEffect срабатывает на всех экземплярах компонента, сколько бы их не было, а не на том одном, который сейчас прирендерился. Получается, что анимация срабатывает у всех, а счётчик увеличивается многократно. Не нашел способ это исправить

- есть кнопка закрытия карточки, но она не работает. Чтобы убрать карточку из массива, нужно обратиться из карточки в компонент SearchBar к массиву cardList, но я не нашел способ, как редактировать данные другого компонента.

- кнопка поиска ищет по трём категориям (персонажи, планеты и корабли) и в случае, если искомого объекта нет, возвращает карточку 'Data not found!'. Каким-то образом эта функция сломалась. Вчера сохранял, всё работало, а сегодня нет. Если включить консольные уведомления и посмотреть в консоль, то видно, что при невалидном запросе сначала идёт поиск по персонажам, потом по планетам, потом по кораблям. Так и должно быть. Но когда поиск по кораблям заканчивается, он не возвращает карточку 'Data not found!', а вызывает поиск по планетам и так запускается бесконечный цикл. Я не понимаю, как из searchForSpaceship() может снова вызываться searchForPlanet(), это невозможно, но почему-то работает так. Обидно, что не пользовался гитом, можно было бы откатить. Так и не смог эту ошибку найти.

- перед загрузкой все протестировал вручную, других ошибок не нашёл

//------------ НЕЙМИНГ И СТИЛЬ КОДА:

- в названиях компонентов, CSS-классов, CSS-id-шников - PascalCase

- в названиях переменных, папок, имён файлов (кроме файлов компонентов) - camelCase

- все глобальные переменные внутри объекта globalData в scripts.ts

- div-ы, которые по смыслу являются внешней оболчкой для внутренних элементов, обязательно имеют название CardPropsCont, SearchBarCont и т.д., с Cont на конце

- внутренние div-ы наследуют название от главного родителя, например, CardTitle, CardButtonClose, CardPropHeight, CardSplitLine и т.д.

- компоненты, функции объявлял и через функции, и через классы, и через функциональное выражение, и через функциональную декларацию для демонстрации, что я знаю синтаксис. В серьёзном проекте, конечно, придерживался бы единого стиля по возможности

- пролинтил styles.styl stylelint'ом, настройки линтера мои кастомные

//------------ КОММЕНТАРИИ ПО ФУНКЦИОНАЛУ:

- событие кнопки random - вызывается функция, которая через Math.random рандомно вызывает одну из трёх функций - вернуть данные о персонаже, о корабле или о планете. Потом происходит запрос на сервер, обращение по рандомному индексу и возвращается рандомная карточка

- событие кнопки search - вся база (персонажи, корабли, планеты) ищется на предмет совпадения json.name с инпутом, который мы ввели. например. 'Luke Skywalker' - это json.name для https://swapi.dev/api/people/1/ . Соответственно, 'Luke Skywalker' на сервере === 'Luke Skywalker' в инпуте, нам возвращаются данные. Если совпадения нет, идёт дальнейший поиск совпадения через цикл for. Приведение к нижнему регистру позволяет вводить имя с маленькой буквы

- на сервере есть неприятная особенность - некоторые адреса пустые. Например, people/17 возвращает error 404, но это удалось обойти в фетч-функции 

- если совпадения нет (например, мы ищем 'superman'), после прогона по всей базе вернется компонент с заголовком 'Data not found', но надо будет подождать, пока поиск по базе закончится

- кнопка scroll-to-top, компонент ButtonUp.tsx . При загрузке страницы у неё включен CSS-класс ButtonUpHidden , который скрывает её. Функция watchScroll самовызваемая, при загрузке страницы она вызывает setInterval, который мониторит значение window.scrollY раз в секунду. Если проскроллено более чем на 1200 пикселей, она вызывает useState, который убирает класс ButtonUpHidden, через анимацию opacity возвращается в 1. Если скролл ниже 1200, кнопка снова скрывается. Пытался ещё менять свойство display, чтобы не только прозрачность менялась, но и в целом кнопка уходила, чтобы нельзя было нажать на невидимую кнопку. Но не получилось почему-то, второй хук просто не работает, значение не присоединяется

- в функциях есть консоль логи, я их специально не убирал, а закомментировал, чтобы можно было раскомментировать и посмотреть как выполяется функция

- debounce поставил на 2,5 сек, чтобы можно было неспеша набирать

//------------ ОБЩИЕ КОММЕНТАРИИ:

- все стили в одном файле, чтобы было удобнее, размер проекта маленький, не критично. С компонентами немного разбил на папки для удобства

- Препроцессор Stylus, нравится больше, чем Sass, использовал и переменные, и миксины для демонстрации

- typescript ругался на импорт компонентов в формате .tsx , хотя приложение работало нормально, поэтому пришлось в некоторых местах вставлять // @ts-ignore . Пытался убрать ошибку через редактирование webpack.config.js и babel.config.js , но не получилось

- в компоненте SearchBar кнопка поиска - это компонент из CSS библиотеки Material UI. Почему-то не получилось привязать к ней onClick, поэтому пришлось кнопку обернуть во внешний div и уже к нему привязать onClick={...}, иначе событие не срабатывало.

- разделительные полосы внутри карточки получаются разной толщины, наверное, какой-то артефакт рендеринга

//------------ ПРИМЕЧАНИЯ, КОТОРЫЕ МОЖНО НАЙТИ В КОДЕ:

примечание 1: эта кнопка - компонент из внешней библиотеки Material UI, я захотел их подключить. Компонент <Button> оттуда, в начале компонента я импортировал её из MUI; чтобы было понятно, откуда взялся компонент, который я не создавал

примечание 2: в этом компоненте много функций. Я пытался выделить их в отдельный .ts файл, чтобы файл с компонентом был незагрязнённый, но не получилось, реакту нужен импорт его методов, не нашёл способ решить проблему

примечание 3: по-хорошему надо было сделать один компонент Card, и менять его свойства (height, mass, hair color для Person, model, length, crew для Spaceship) в зависимости от того, какой запрос сделан на сервер. Но я уже завязал логику с тремя компонентами CardPerson, CardPlanet, CardSpaceship, и рефакторить не было времени.

примечание 5: изначально функция выглядела как setCardList(cardList.concat(card)); но я захотел, чтобы новые карточки подгружались сверху, а не снизу. переписал в setCardList(cardList = cardList.unshift(card)); но тайпскрипт опять начал ругаться, что ему всё не так, хотя всё работает нормально и никаких ошибок в логике я не вижу там.
